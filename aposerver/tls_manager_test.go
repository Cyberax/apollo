package aposerver

import (
	"apollo/data"
	"bytes"
	"crypto/tls"
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"io/ioutil"
	"os"
	"testing"
)

func TestMain(m *testing.M) {
	logrus.SetLevel(logrus.FatalLevel)
	os.Exit(m.Run())
}

func TestTlsManager(t *testing.T) {
	store := data.NewFakeMemStore()
	store.InitSchema(map[string]int64{
		TlsTableName: 5,
	})

	manager := NewTlsManager()
	manager.Close() // No-op, but safe
	defer manager.Close()

	err := manager.Init(store, "somehost", 123, "auto",
		"", "self")
	assert.NoError(t, err)

	// TLS manager should have created the keyfile and the certfile in the temporary directory
	// and populated them with the autogenerated certificate. Additionally it has stored
	// it in the database.
	_, err = tls.LoadX509KeyPair(manager.TLSCertFile, manager.TLSKeyFile)
	assert.NoError(t, err)

	// Now create a second TLS manager - it should re-use the stored certificate
	manager2 := NewTlsManager()
	defer manager2.Close()
	err = manager2.Init(store, "somehost", 123, "auto",
		"","self")
	assert.NoError(t, err)

	_, err = tls.LoadX509KeyPair(manager2.TLSCertFile, manager2.TLSKeyFile)
	assert.NoError(t, err)

	// The files must be equal
	cert1, _ := ioutil.ReadFile(manager.TLSCertFile)
	cert2, _ := ioutil.ReadFile(manager2.TLSCertFile)
	assert.True(t, bytes.Equal(cert1, cert2))

	key1, _ := ioutil.ReadFile(manager.TLSKeyFile)
	key2, _ := ioutil.ReadFile(manager2.TLSKeyFile)
	assert.True(t, bytes.Equal(key1, key2))

	// Make sure we handle errors correctly
	store.StoreValues(TlsTableName, []TlsData{{
			Key: "server2",  CertData: string("haha"),  KeyData: string("bad")}})
	manager3 := NewTlsManager()
	err = manager3.Init(store, "somehost", 123, "auto",
		"", "self")
	assert.Error(t, err)
}

func TestUrlProbing(t *testing.T) {
	store := data.NewFakeMemStore()
	store.InitSchema(map[string]int64{TlsTableName: 5})

	manager := NewTlsManager()
	defer manager.Close()
	tlsData, err := makeNewCert()
	assert.NoError(t, err)

	cer, err := tls.X509KeyPair([]byte(tlsData.CertData), []byte(tlsData.KeyData))
	assert.NoError(t, err)

	config := &tls.Config{Certificates: []tls.Certificate{cer}}
	ln, err := tls.Listen("tcp", ":23413", config)
	assert.NoError(t, err)
	defer ln.Close()

	go func() {
		conn, err := ln.Accept()
		assert.NoError(t, err)
		conn.Write([]byte("Hello\n"))
		defer conn.Close()
	}()

	err = manager.Init(store, "somehost", 123, "/SOME/a",
		"/some/b", "localhost:23413")
	assert.NoError(t, err)

	assert.Equal(t, getCertBody([]byte(tlsData.CertData)),
		manager.OurCert)
}

func TestTlsNonAuto(t *testing.T) {
	manager := NewTlsManager()
	tlsData, err := makeNewCert()
	assert.NoError(t, err)

	file, err := ioutil.TempFile("", "tlscert")
	assert.NoError(t, err)
	file.Close()
	ioutil.WriteFile(file.Name(), []byte(tlsData.CertData), 0600)
	defer os.Remove(file.Name())

	err = manager.Init(nil, "somehost", 123, file.Name(),
		"/file2", "self")
	assert.NoError(t, err)

	assert.Equal(t, "somehost", manager.TLSHost)
	assert.Equal(t, 123, manager.TLSPort)
	assert.Equal(t, file.Name(), manager.TLSCertFile)
	assert.Equal(t, "/file2", manager.TLSKeyFile)

	assert.Equal(t, getCertBody([]byte(tlsData.CertData)),
		manager.OurCert)
}
